%----------------------------------------------------------------------------------------
%	CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt,a4paper,oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{natbib}
\usepackage{amsmath}
\usepackage{lipsum}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[a4paper,left=2cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}

%----------------------------------------------------------------------------------------
%	INFORMATION
%----------------------------------------------------------------------------------------

\title{Programação Lógica para Problemas de Pesquisa e Análise Sintática da Gramática Portuguesa\\
  \vspace{0.1in}
  \large{Inteligência Artificial - Trabalho 3}
}

\author{João Ramos\footnote{João Ramos - 201204672} e Pedro Paredes\footnote{Pedro Paredes - 201205725}, DCC - FCUP}

\date{Maio 2015}

\renewcommand{\tablename}{Tabela}
\renewcommand{\figurename}{Figura}
\renewcommand{\refname}{Referências}

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Introdução}
\label{sec:intro}

O paradigma lógico tem um nível de abstração que permite abordagens e
representações diferentes para vários problemas. Atualmente, existe
uma vasta investigação na área em diversos temas, principalmente
usando a linguagem \texttt{Prolog}.

Neste trabalho iremos comparar a implementação de soluções em
\texttt{Prolog} com diferentes linguagens imperativas em diferentes
tipos de problemas. O primeiro tipo de problema será um problema de
pesquisa que envolve diferentes tipos de perguntas que requerem uma
aproximação semelhante à desenvolvida no trabalho 1. O segundo tipo de
problema é de interpretar uma gramática para reconhecimento de frases
na língua portuguesa.

O resto do relatório está organizado da seguinte forma. Na Secção
\ref{sec:pes} descrevem-se as implementações relativas ao problema de
pesquisa. Na Secção \ref{sec:sin} descrevem-se as implementações
relativas ao problema da gramática. Finalmente na Secção
\ref{sec:conc} fazem-se algumas notas finais.

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Problemas de pesquisa}
\label{sec:pes}

O primeiro problema pede que se responda a três tipos de perguntas:

\begin{itemize}
\item Em que dias da semana há um voo direto entre duas localizações
  determinadas?
\item Que rotas existem que permitem chegar de uma determinada
  localização a outra determinada localização num dado dia,
  respeitando um tempo mínimo de 40 minutos entre cada voo?
\item Que rotas existem que permitam visitar uma dada lista de
  cidades, começando e terminando a viagem numa mesma dada cidade,
  iniciando a viagem num dado dia e fazendo um voo por dia?
\end{itemize}

\textbf{Nota:} A última questão foi alterada ligeiramente do enunciado
visto que a pergunta era um pouco ambígua e por isso levava a
diferentes interpretações (por exemplo, se a restrição é no máximo um
por dia, então isso seria equivalente a não ter restrição no sentido
do problema, pois poder-se-ia simplesmente voar no mesmo dia da semana
seguinte). Visto que a dificuldade da pergunta é a mesma, fixá-la
ajudou-nos a organizar as implementações.

\subsection{Implementação em \texttt{Prolog}}

Na implementação em \texttt{Prolog} usámos dois ficheiros com
predicados. O primeiro, \texttt{main.pl} contém os predicados os
predicados que respondem às questões anteriores e vários predicados
auxiliares. Adicionalmente, temos um ficheiro \texttt{bd.pl} que
contém as entradas na base de dados de voos (na forma de predicados
\texttt{timetable/3}. Os predicados que respondem às questões
anteriores são os seguintes.

Para a primeira questão, temos o predicado \texttt{directflight/3}, que
aceita o cabeçalho \texttt{directflight( +Place1, +Place2, -Day )}, onde
\texttt{Place1} representa a localização inicial, \texttt{Place2}
representa a localização final e a resposta que o predicado dá é o
\texttt{Day}, que representa cada dia que satisfaz as condições da
pergunta.

Para a segunda questão, temos o predicado \texttt{route/4}, que aceita
o cabeçalho \texttt{route( +Place1, +Place2, ?Day, -Route )}, onde
\texttt{Place1} representa a localização inicial, \texttt{Place2}
representa a localização final, \texttt{Day} é um argumento opcional
que representa o dia da viagem e finalmente a resposta estará em
\texttt{Route}, que representa a rota da viagem no formato dado no
enunciado do trabalho.

Finalmente, a terceira questão, temos o predicado \texttt{visit/4},
que aceita o cabeçalho \texttt{visit( +Placei, +Day, +Destlist,
  -Route )}, onde \texttt{Placei} representa a localização inicial e
final, \texttt{Day} é representa o dia em que começa a viagem,
\texttt{Destlist} é uma lista de destinos onde se pretende passar e
finalmente a resposta estará em \texttt{Route}, que representa a rota
da viagem no formato dado no enunciado do trabalho.

Além disto, foi implementado um programa em \texttt{C} que utiliza o
\textit{foreign interface} do \texttt{Prolog} para comunicarem, no
ficheiro \texttt{main.c}. Para compilar este código deve-se usar o
comando \texttt{swipl-ld -o main main.c main.pl bd.pl}. Este pequeno
programa apenas introduz um menu que permite chamar os vários
predicados para responder às perguntas dinamicamente.

\subsection{Implementação em \textit{Ruby}}

Na implementação em \texttt{Ruby} usámos apenas um ficheiro que
responde às três perguntas, juntamente com um menu semelhante ao usado
no programa em \texttt{C} que utiliza o \texttt{Prolog} para responder
às perguntas. Os vôos são armazenados numa \textit{hash table} para
poderem ser obtidos de forma eficiente quando necessários.

Para a primeira questão, a função responsável por responder à mesma
apenas percorre a lista de vôos entre as cidades dadas, imprimindo
informações dos mesmos à medida que é feita a união dos conjuntos de
dias em que cada vôo está disponível.

Para a segunda questão, é feita uma pesquisa em profundidade mantendo
no estado as cidades já visitadas para não voltar às mesmas, e imprimir
informação de cada rota no final. Nota para que apenas são pesquisados
espaços de procura válidos. Caso apenas estivéssemos interessados em
obter uma das rotas (a mais rápida por exemplo) podiamos ter usado um
algoritmo diferente (algoritmo de \textit{Dijkstra} por exemplo).

Finalmente, a terceira questão, são geradas todas as possíveis ordem de
visita das cidades e, para cada uma, é verificado se a mesma é possível
utilizando a função responsável por responder à primeira pergunta.

\subsection{Notas das Implementações}

Neste problema, a representação em \texttt{Prolog} fica bastante
natural, pois visto que o funcionamento do \texttt{Prolog} é baseado
em \textit{backtracking} (além de outros conceitos, como unificação,
claro). Porém, a eficiência da segunda pergunta podia ser bastante
otimizada com algoritmos mais específicos para grafos, cuja
representação em \texttt{Prolog} não é tão natural (apesar de ser
possível).

Dito isto, os operadores de \texttt{Prolog} em conjunto com as
definições naturais dos predicados ajudam a que a implementação em
\texttt{Prolog} fique mais simplificada, facilitando a sua
implementação.

%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Análise Sintática da Gramática Portuguesa}
\label{sec:sin}

Para o segundo problema, é pedido que se construa um programa que
analise frases em português, indicando se são válidas ou não e
devolvendo a \textit{parse tree} da frase segundo estruturas
sintáticas. Apenas foi considerada a sintaxe das frase, tendo sido
ignorada a semântica, como indicado no enunciado.
 
\subsection{Gramática utilizada}

\lipsum[1]

\lipsum[2]

\lipsum[3]


\subsection{Implementação em \texttt{Prolog}}

\lipsum[1]

\lipsum[2]

\lipsum[3]

\subsection{Implementação em \texttt{Python}}

Na implementação em \texttt{Python} utilizámos o módulo \texttt{nltk} e
usámos dois ficheiros. O primeiro, \texttt{pt\_grammar.fcfg}, contém a nossa
gramática da língua portuguesa no formato aceite pelo \texttt{nltk}, assim como
a base de dados de palavras com a sua respectiva categorização lexicográfica.
E temos o ficheiro \texttt{dcg.py} que implementa a função \texttt{sentence\_analysis}
que recebe a frase a analisar como argumento e, caso a mesma esteja correcta, mostra
a análise morfológica da mesma.

A gramática utilizada é a mesma introduzida no início desta secção. Assim com a base
de dados utilizada.

Para a implementação da função \texttt{sentence\_analysis} começamos por carregar a
nossa gramática para o parser e fazer um pequeno tratamento da frase recebida (ignorar
sinais de pontuação, converter todos os caracteres para minúsculas e dividir a frase
na lista das palavras que a compõe). Após isto, o \texttt{nltk} usa a nossa gramática
para gerar as árvores da análise sintática da frase recebida.

Implementámos ainda a função \texttt{assert\_sentence\_analysis} que tem como objectivo
testar a nossa função de análise sintática com os exemplos fornecidos no enunciado do
trabalho.

\subsection{Notas das Implementações}

Neste problema, as representações em \texttt{Prolog} e \texttt{Python} ficam ambas bastante
naturais e parecidas graças ao módulo \texttt{nltk} utilizado no python que permite uma
implementação simples mas bastante poderosa da gramática.

Ambas as implementações, particularmente a implementação em \texttt{Python} graças às
potencialidades oferecidas pelo \texttt{nltk}, permitem melhorias significativas não só a
nível de eficiência como da qualidade da análise sintática mantendo as implementações com
baixo nível de complexidade.


%----------------------------------------------------------------------------------------
%	SECTION 3
%----------------------------------------------------------------------------------------

\section{Conclusão}
\label{sec:conc}

Este trabalho permitiu explorar e ver em prática a utilização de uma linguagem com um
diferente paradigma para a resolução de problemas com características diferentes.

O paradigma lógico permite, nos problemas analisados, implementações mais concisas e
simples, mesmo sem ser necessário recorrer a módulos extra, como foi o caso na implementação
do segundo problema numa linguagem imperativa em que, para ter uma implementação simples
mas poderosa foi necessário utilizar um módulo extra.

Apesar disto, há situações e problemas em que a situação se inverte, ou seja, em que é mais
simples a implementação numa linguagem imperativa em relação a uma linguagem lógica. Contudo,
é sobre bom ter mais ``armas'' à disposição para atacar cada problema da melhor maneira.


\bibliographystyle{plain}
\bibliography{lab_report_3}

\end{document}
